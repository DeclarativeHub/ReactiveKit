//
//  The MIT License (MIT)
//
//  Copyright (c) 2016 Srdan Rasic (@srdanrasic)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

// MARK: - OperationEventType

/// Represents an operation event.
public protocol OperationEventType: EventType, Errorable {
}

// MARK: - OperationEvent

/// Represents an operation event.
public enum OperationEvent<T, E: Error>: OperationEventType {

  /// The type of elements generated by the stream.
  public typealias Element = T

  /// The type of error generated by the stream.
  public typealias ErrorType = E

  /// Contains element.
  case Next(T)

  /// Contains error.
  case Failure(E)

  /// Stream is completed.
  case Completed

  /// Create new `.Next` event.
  public static func next(_ element: T) -> OperationEvent<T, E> {
    return .Next(element)
  }

  /// Create new `.Completed` event.
  public static func completed() -> OperationEvent<T, E> {
    return .Completed
  }

  /// Create new `.Failure` event.
  public static func failure(_ error: ErrorType) -> OperationEvent<T, E> {
    return .Failure(error)
  }

  /// Extract an element from a non-terminal (`.Next`) event.
  public var element: Element? {
    switch self {
    case .Next(let element):
      return element
    default:
      return nil
    }
  }

  /// Does the event mark failure of a stream? `True` if event is `.Failure`.
  public var isFailure: Bool {
    switch self {
    case .Failure:
      return true
    default:
      return false
    }
  }

  /// Does the event mark completion of a stream? `True` if event is `.Completion`.
  public var isCompletion: Bool {
    switch self {
    case .Completed:
      return true
    default:
      return false
    }
  }

  /// Extract an error from a failure (`.Failure`) event.
  public var error: ErrorType? {
    switch self {
    case .Failure(let error):
      return error
    default:
      return nil
    }
  }
}

// MARK: - OperationEventType Extensions


public extension OperationEventType {

  public var unbox: OperationEvent<Element, ErrorType> {
    if let element = element {
      return OperationEvent.Next(element)
    } else if let error = error {
      return OperationEvent.failure(error)
    } else {
      return OperationEvent.Completed
    }
  }

  public func map<U>(_ transform: (Element) -> U) -> OperationEvent<U, ErrorType> {
    switch self.unbox {
    case .Next(let element):
      return .Next(transform(element))
    case .Failure(let error):
      return .Failure(error)
    case .Completed:
      return .Completed
    }
  }

  public func tryMap<U>(_ transform: (Element) -> Result<U, ErrorType>) -> OperationEvent<U, ErrorType> {
    switch self.unbox {
    case .Next(let element):
      switch transform(element)  {
      case .Success(let element):
        return .Next(element)
      case .Failure(let error):
        return .Failure(error)
      }
    case .Failure(let error):
      return .Failure(error)
    case .Completed:
      return .Completed
    }
  }

  public func mapError<F: Error>(_ transform: (ErrorType) -> F) -> OperationEvent<Element, F> {
    switch self.unbox {
    case .Next(let element):
      return .Next(element)
    case .Failure(let error):
      return .Failure(transform(error))
    case .Completed:
      return .Completed
    }
  }
}

// MARK: - OperationType

/// Represents a stream that can fail.
public protocol OperationType: _StreamType {

  /// The type of elements generated by the stream.
  associatedtype Element

  /// The type of error generated by the stream.
  associatedtype ErrorType: Error

  /// Underlying raw stream. Operation is just a wrapper over `RawStream` that
  /// operates on events of `OperationEvent` type.
  var rawStream: RawStream<OperationEvent<Element, ErrorType>> { get }

  /// Register an observer that will receive events from the operation. Registering
  /// an observer starts the operation. Disposing the returned disposable can
  /// be used to cancel the operation.
  func observe(observer: @escaping (OperationEvent<Element, ErrorType>) -> Void) -> Disposable
}

public extension OperationType {

  /// Transform the operation by transforming underlying raw stream.
  public func lift<U, E: Error>(transform: @escaping (RawStream<OperationEvent<Element, ErrorType>>) -> RawStream<OperationEvent<U, E>>) -> Operation<U, E> {
    return Operation<U, E> { observer in
      return transform(self.rawStream).observe(observer: observer.observer)
    }
  }

  /// Register an observer that will receive events from a stream. Registering
  /// an observer starts the operation. Disposing the returned disposable can
  /// be used to cancel the operation.
  public func observe(observer: @escaping (OperationEvent<Element, ErrorType>) -> Void) -> Disposable {
    return rawStream.observe(observer: observer)
  }
}

extension OperationEvent: CustomStringConvertible {

  public var description: String {
    switch self {
    case .Next(let element):
      return ".Next(\(element))"
    case .Failure(let error):
      return ".Failure(\(error))"
    case .Completed:
      return ".Completed"
    }
  }
}

// MARK: - Operation

/// Represents a stream that can fail.
/// Well-formed operation conforms to the grammar: `Next* (Completed | Failure)`.
public struct Operation<T, E: Error>: OperationType {

  /// The type of elements generated by the operation.
  public typealias Element = T

  /// The type of error generated by the operation.
  public typealias ErrorType = E

  /// Underlying raw stream. Operation is just a wrapper over `RawStream` that
  /// operates on events of `OperationEvent` type.
  public let rawStream: RawStream<OperationEvent<T, E>>

  /// Create a new operation from a raw stream.
  public init(rawStream: RawStream<OperationEvent<T, E>>) {
    self.rawStream = rawStream
  }

  /// Create a new operation using a producer.
  public init(producer: @escaping (Observer<OperationEvent<T, E>>) -> Disposable) {
    rawStream = RawStream(producer: producer)
  }
}

// MARK: - Extensions
// MARK: Creating an operation

public extension Operation {

  /// Create an operation that emits given element and then completes.
  public static func just(_ element: Element) -> Operation<Element, ErrorType> {
    return Operation { observer in
      observer.next(element)
      observer.completed()
      return NotDisposable
    }
  }

  /// Create an operation that emits given sequence of elements and then completes.
  public static func sequence<S: Sequence>(_ sequence: S) -> Operation<Element, ErrorType> where S.Iterator.Element == Element {
    return Operation { observer in
      sequence.forEach(observer.next)
      observer.completed()
      return NotDisposable
    }
  }

  /// Create an operation that fails with given error without emitting any elements.
  public static func failure(_ error: ErrorType) -> Operation<Element, ErrorType> {
    return Operation { observer in
      observer.failure(error)
      observer.completed()
      return NotDisposable
    }
  }

  /// Create an operation that completes without emitting any elements.
  public static func completed() -> Operation<Element, ErrorType> {
    return Operation { observer in
      observer.completed()
      return NotDisposable
    }
  }

  /// Create an operation that never completes.
  public static func never() -> Operation<Element, ErrorType> {
    return Operation { observer in
      return NotDisposable
    }
  }

  /// Create an operation that emits an integer every `interval` time on a given queue.
  public static func interval(_ interval: TimeValue, queue: DispatchQueue) -> Operation<Int, ErrorType> {
    return Operation<Int, ErrorType>(rawStream: RawStream.interval(interval, queue: queue))
  }

  /// Create an operation that emits given element after `time` time on a given queue.
  public static func timer(element: Element, time: TimeValue, queue: DispatchQueue) -> Operation<Element, ErrorType> {
    return Operation(rawStream: RawStream.timer(events: [.Next(element), .Completed], time: time, queue: queue))
  }
}

// MARK: Transforming operation

public extension OperationType {

  /// Batch the elements into arrays of given size.
  public func buffer(size: Int) -> Operation<[Element], ErrorType> {
    return Operation { observer in
      var buffer: [Element] = []
      return self.observe { event in
        switch event {
        case .Next(let element):
          buffer.append(element)
          if buffer.count == size {
            observer.next(buffer)
            buffer.removeAll()
          }
        case .Completed:
          observer.completed()
        case .Failure(let error):
          observer.failure(error)
        }
      }
    }
  }

  /// Map each event into an operation and then flatten those operations using
  /// the given flattening strategy.
  public func flatMap<U: OperationType>(strategy: FlatMapStrategy, transform: @escaping (Element) -> U) -> Operation<U.Event.Element, ErrorType> where U.Event: OperationEventType, U.Event.ErrorType == ErrorType {
    switch strategy {
    case .Latest:
      return map(transform).switchToLatest()
    case .Merge:
      return map(transform).merge()
    case .Concat:
      return map(transform).concat()
    }
  }

  /// Map each event into an operation and then flattens inner operations.
  public func flatMapLatest<U: OperationType>(transform: @escaping (Element) -> U) -> Operation<U.Event.Element, ErrorType> where U.Event: OperationEventType, U.Event.ErrorType == ErrorType {
    return flatMap(strategy: .Latest, transform: transform)
  }

  /// Map each event into an operation and then flattens inner operations.
  public func flatMapMerge<U: OperationType>(transform: @escaping (Element) -> U) -> Operation<U.Event.Element, ErrorType> where U.Event: OperationEventType, U.Event.ErrorType == ErrorType {
    return flatMap(strategy: .Merge, transform: transform)
  }
  /// Map each event into an operation and then flattens inner operations.
  public func flatMapConcat<U: OperationType>(transform: @escaping (Element) -> U) -> Operation<U.Event.Element, ErrorType> where U.Event: OperationEventType, U.Event.ErrorType == ErrorType {
    return flatMap(strategy: .Concat, transform: transform)
  }

  /// Transform each element by applying `transform` on it.
  public func map<U>(_ transform: @escaping (Element) -> U) -> Operation<U, ErrorType> {
    return lift { $0.map { $0.map(transform) } }
  }

  /// Maps elements to Void.
  public func eraseType() -> Operation<Void, ErrorType> {
    return map { _ in }
  }

  /// Transform error by applying `transform` on it.
  public func mapError<F: Error>(transform: @escaping (ErrorType) -> F) -> Operation<Element, F> {
    return lift { $0.map { $0.mapError(transform) }  }
  }

  /// Apply `combine` to each element starting with `initial` and emit each
  /// intermediate result. This differs from `reduce` which emits only final result.
  public func scan<U>(_ initial: U, _ combine: @escaping (U, Element) -> U) -> Operation<U, ErrorType> {
    return lift { stream in
      return stream.scan(.Next(initial)) { memo, new in
        switch new {
        case .Next(let element):
          return .Next(combine(memo.element!, element))
        case .Completed:
          return .Completed
        case .Failure(let error):
          return .Failure(error)
        }
      }
    }
  }

  /// Transform each element by applying `transform` on it.
  public func tryMap<U>(_ transform: @escaping (Element) -> Result<U, ErrorType>) -> Operation<U, ErrorType> {
    return lift { $0.map { $0.tryMap(transform) } }
  }

  /// Convert the operation to a concrete operation.
  public func toOperation() -> Operation<Element, ErrorType> {
    return Operation(rawStream: self.rawStream)
  }

  /// Converts operations into two streams: Element stream and Error stream.
  public func toStream() -> (Stream<Element>, Stream<ErrorType>) {
    let shared = shareReplay()
    return (shared.toStream(justLogError: false), shared.toErrorStream())
  }

  /// Converts operations into two streams, Element stream and Error stream, and maps error to another type.
  public func toStream<U>(mapError: @escaping (ErrorType) -> U) -> (Stream<Element>, Stream<U>) {
    let shared = shareReplay()
    return (shared.toStream(justLogError: false), shared.toErrorStream().map(mapError))
  }

  /// Convert the operation to a stream by ignoring the error.
  public func toStream(justLogError logError: Bool, completeOnError: Bool = false, file: String = #file, line: Int = #line) -> Stream<Element> {
    return Stream { observer in
      return self.observe { event in
        switch event {
        case .Next(let element):
          observer.next(element)
        case .Failure(let error):
          if completeOnError {
            observer.completed()
          }
          if logError {
            print("Operation at \(file):\(line) encountered an error: \(error)")
          }
        case .Completed:
          observer.completed()
        }
      }
    }
  }

  /// Convert the operation to a stream by feeding the error into a subject.
  public func toStream<S: SubjectType>(feedErrorInto listener: S, logError: Bool = true, completeOnError: Bool = false, file: String = #file, line: Int = #line) -> Stream<Element> where S.Event.Element == ErrorType {
    return feedError(into: listener).toStream(justLogError: logError, completeOnError: completeOnError, file: file, line: line)
  }

  /// Convert operation to a stream by propagating default element if error happens.
  public func toStream(recoverWith element: Element) -> Stream<Element> {
    return Stream { observer in
      return self.observe { event in
        switch event {
        case .Next(let element):
          observer.next(element)
        case .Failure:
          observer.next(element)
          observer.completed()
        case .Completed:
          observer.completed()
        }
      }
    }
  }

  /// Maps the operation into an error stream.
  public func toErrorStream() -> Stream<ErrorType> {
    return Stream<ErrorType> { observer in
      return self.observe { taskEvent in
        switch taskEvent {
        case .Next:
          break
        case .Completed:
          observer.completed()
        case .Failure(let error):
          observer.next(error)
        }
      }
    }
  }

  /// Batch each `size` elements into another operations.
  public func window(size: Int) -> Operation<Operation<Element, ErrorType>, ErrorType> {
    return buffer(size: size).map { Operation.sequence($0) }
  }
}

// MARK: Filtration

extension OperationType {

  /// Emit an element only if `interval` time passes without emitting another element.
  public func debounce(interval: TimeValue, on queue: DispatchQueue) -> Operation<Element, ErrorType> {
    return lift { $0.debounce(interval: interval, on: queue) }
  }

  /// Emit first element and then all elements that are not equal to their predecessor(s).
  public func distinct(areDistinct: @escaping (Element, Element) -> Bool) -> Operation<Element, ErrorType> {
    return lift { $0.distinct(areDistinct: areDistinct) }
  }

  /// Emit only element at given index if such element is produced.
  public func element(at index: Int) -> Operation<Element, ErrorType> {
    return lift { $0.element(at: index) }
  }

  /// Emit only elements that pass `include` test.
  public func filter(include: @escaping (Element) -> Bool) -> Operation<Element, ErrorType> {
    return lift { $0.filter { $0.element.flatMap(include) ?? true } }
  }

  /// Emit only the first element generated by the operation and then complete.
  public func first() -> Operation<Element, ErrorType> {
    return lift { $0.first() }
  }

  /// Ignore all elements (just propagate terminal events).
  public func ignoreElements() -> Operation<Element, ErrorType> {
    return lift { $0.ignoreElements() }
  }

  /// Emit only last element generated by the stream and then completes.
  public func last() -> Operation<Element, ErrorType> {
    return lift { $0.last() }
  }

  /// Periodically sample the stream and emit latest element from each interval.
  public func sample(interval: TimeValue, on queue: DispatchQueue) -> Operation<Element, ErrorType> {
    return lift { $0.sample(interval: interval, on: queue) }
  }

  /// Suppress first `count` elements generated by the operation.
  public func skip(first count: Int) -> Operation<Element, ErrorType> {
    return lift { $0.skip(first: count) }
  }

  /// Suppress last `count` elements generated by the operation.
  public func skip(last count: Int) -> Operation<Element, ErrorType> {
    return lift { $0.skip(last: count) }
  }

  /// Emit only first `count` elements of the operation and then complete.
  public func take(first count: Int) -> Operation<Element, ErrorType> {
    return lift { $0.take(first: count) }
  }

  /// Emit only last `count` elements of the operation and then complete.
  public func take(last count: Int) -> Operation<Element, ErrorType> {
    return lift { $0.take(last: count) }
  }

  /// Throttle operation to emit at most one element per given `seconds` interval.
  public func throttle(seconds: TimeValue) -> Operation<Element, ErrorType> {
    return lift { $0.throttle(seconds: seconds) }
  }
}

extension OperationType where Element: Equatable {

  /// Emit first element and then all elements that are not equal to their predecessor(s).
  public func distinct() -> Operation<Element, ErrorType> {
    return lift { $0.distinct() }
  }
}

public extension OperationType where Element: OptionalType, Element.Wrapped: Equatable {

  /// Emit first element and then all elements that are not equal to their predecessor(s).
  public func distinct() -> Operation<Element, ErrorType> {
    return lift { $0.distinct() }
  }
}

public extension OperationType where Element: OptionalType {

  /// Suppress all `nil`-elements.
  public func ignoreNil() -> Operation<Element.Wrapped, ErrorType> {
    return Operation { observer in
      return self.observe { event in
        switch event {
        case .Next(let element):
          if let element = element._unbox {
            observer.next(element)
          }
        case .Failure(let error):
          observer.failure(error)
        case .Completed:
          observer.completed()
        }
      }
    }
  }
}

// MARK: Combination

extension OperationType {

  /// Emit a pair of latest elements from each operation. Starts when both operations
  /// emit at least one element, and emits `.Next` when either operation generates an element.
  public func combineLatest<O: OperationType>(with other: O) -> Operation<(Element, O.Element), ErrorType> where O.ErrorType == ErrorType {
    return lift {
      return $0.combineLatest(with: other.toOperation()) { myLatestElement, my, theirLatestElement, their, isMy in
        switch (my, their) {
        case (.Completed, .Completed):
          return OperationEvent.Completed
        case (.Next(let myElement), .Next(let theirElement)):
          return OperationEvent.Next(myElement, theirElement)
        case (.Next(let myElement), .Completed):
          if let theirLatestElement = theirLatestElement, isMy {
            return OperationEvent.Next(myElement, theirLatestElement)
          } else {
            return nil
          }
        case (.Completed, .Next(let theirElement)):
          if let myLatestElement = myLatestElement {
            return OperationEvent.Next(myLatestElement, theirElement)
          } else {
            return nil
          }
        case (.Failure(let error), _):
          return OperationEvent.failure(error)
        case (_, .Failure(let error)):
          return OperationEvent.failure(error)
        default:
          fatalError("This will never execute: Swift compiler cannot infer switch completeness.")
        }
      }
    }
  }

  /// Merge emissions from both source and `other` into one operation.
  public func merge<O: OperationType>(with other: O) -> Operation<Element, ErrorType> where O.Element == Element, O.ErrorType == ErrorType {
    return lift { $0.merge(with: other.rawStream) }
  }

  /// Prepend given element to the operation emission.
  public func start(with element: Element) -> Operation<Element, ErrorType> {
    return lift { $0.start(with: .Next(element)) }
  }

  /// Emit elements from source and `other` in combination. This differs from `combineLatestWith` in
  /// that combinations are produced from elements at same positions.
  public func zip<O: OperationType>(with other: O) -> Operation<(Element, O.Element), ErrorType> where O.ErrorType == ErrorType {
    return lift {
      return $0.zip(with: other.toOperation()) { my, their in
        switch (my, their) {
        case (.Next(let myElement), .Next(let theirElement)):
          return OperationEvent.Next(myElement, theirElement)
        case (_, .Completed):
          return OperationEvent.Completed
        case (.Completed, _):
          return OperationEvent.Completed
        case (.Failure(let error), _):
          return OperationEvent.failure(error)
        case (_, .Failure(let error)):
          return OperationEvent.failure(error)
        default:
          fatalError("This will never execute: Swift compiler cannot infer switch completeness.")
        }
      }
    }
  }

  /// Combines two operations into an operation of pairs of elements whenever the receiver emits an element with the latest element from the given operation.
  public func withLatest<O: OperationType>(from other: O) -> Operation<(Element, O.Element), ErrorType> where O.ErrorType == ErrorType {
    return lift {
      return $0.combineLatest(with: other.toOperation()) { myLatestElement, my, theirLatestElement, their, isMy in
        switch (my, their) {
        case (.Completed, _):
          return OperationEvent.Completed
        case (.Next(let myElement), .Next(let theirElement)):
          guard isMy else { return nil }
          return OperationEvent.Next(myElement, theirElement)
        case (.Next(let myElement), .Completed):
          guard isMy else { return nil }
          if let theirLatestElement = theirLatestElement {
            return OperationEvent.Next(myElement, theirLatestElement)
          } else {
            return nil
          }
        case (.Failure(let error), _):
          return OperationEvent.failure(error)
        case (_, .Failure(let error)):
          return OperationEvent.failure(error)
        default:
          fatalError("This will never execute: Swift compiler cannot infer switch completeness.")
        }
      }
    }
  }
}

// MARK: Error Handling

extension OperationType {

  /// Map failure event into another operation and continue with that operation. Also called `catch`.
  public func flatMapError<U: OperationType>(recover: @escaping (ErrorType) -> U) -> Operation<Element, U.ErrorType> where U.Element == Element {
    return Operation<U.Element, U.ErrorType> { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)

      serialDisposable.otherDisposable = self.observe { taskEvent in
        switch taskEvent {
        case .Next(let value):
          observer.next(value)
        case .Completed:
          observer.completed()
        case .Failure(let error):
          serialDisposable.otherDisposable = recover(error).observe { event in
            observer.observer(event)
          }
        }
      }

      return serialDisposable
    }
  }

  /// Map failure event into another operation and continue with that operation. Also called `catch`.
  public func flatMapError<S: StreamType>(recover: @escaping (ErrorType) -> S) -> Stream<Element> where S.Element == Element {
    return Stream<Element> { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)

      serialDisposable.otherDisposable = self.observe { taskEvent in
        switch taskEvent {
        case .Next(let value):
          observer.next(value)
        case .Completed:
          observer.completed()
        case .Failure(let error):
          serialDisposable.otherDisposable = recover(error).observe { event in
            observer.observer(event)
          }
        }
      }

      return serialDisposable
    }
  }

  /// Restart the operation in case of failure at most `times` number of times.
  public func retry(times: Int) -> Operation<Element, ErrorType> {
    return lift { $0.retry(times: times) }
  }
}

extension OperationType where Element: ResultType {

  /// Dematerialize elements of `ResultType` into `.Next` or `.Error` events.
  public func dematerialize(mapOutterError: @escaping (ErrorType) -> Element.ErrorType) -> Operation<Element.Value, Element.ErrorType> {
    return Operation { observer in
      return self.observe { event in
        switch event {
        case .Completed:
          observer.completed()
        case .Failure(let error):
          observer.failure(mapOutterError(error))
        case .Next(let result):
          if let value = result.value {
            observer.next(value)
          } else {
            observer.failure(result.error!)
          }
        }
      }
    }
  }
}

//  MARK: Utilities

extension OperationType {

  /// Set the execution context in which to execute the operation (i.e. in which to run
  /// the operation's producer).
  public func executeIn(_ context: @escaping ExecutionContext) -> Operation<Element, ErrorType> {
    return lift { $0.executeIn(context) }
  }

  /// Delay stream events for `interval` time.
  public func delay(interval: TimeValue, on queue: DispatchQueue) -> Operation<Element, ErrorType> {
    return lift { $0.delay(interval: interval, on: queue) }
  }

  /// Do side-effect upon various events.
  public func doOn(next: ((Element) -> ())? = nil,
                   failure: ((ErrorType) -> ())? = nil,
                   start: (() -> Void)? = nil,
                   completed: (() -> Void)? = nil,
                   disposed: (() -> ())? = nil
    ) -> Operation<Element, ErrorType> {
    return Operation { observer in
      start?()
      let disposable = self.observe { event in
        switch event {
        case .Next(let value):
          next?(value)
        case .Failure(let error):
          failure?(error)
        case .Completed:
          completed?()
        }
        observer.observer(event)
      }
      return BlockDisposable {
        disposable.dispose()
        disposed?()
      }
    }
  }

  /// Use `doOn` to log various events.
  public func debug(id: String = "Untitled Operation") -> Operation<Element, ErrorType> {
    return doOn(next: { element in
        print("\(id): Next(\(element))")
      }, failure: { error in
        print("\(id): Failure(\(error))")
      }, start: { 
        print("\(id): Start")
      }, completed: { 
        print("\(id): Completed")
      }, disposed: {
        print("\(id): Disposed")
      })
  }

  /// Set the execution context in which to dispatch events (i.e. in which to run observers).
  public func observeIn(_ context: @escaping ExecutionContext) -> Operation<Element, ErrorType> {
    return lift { $0.observeIn(context) }
  }

  /// Supress non-terminal events while last event generated on other stream is `false`.
  public func pausable<S: _StreamType>(by other: S) -> Operation<Element, ErrorType> where S.Event.Element == Bool {
    return lift { $0.pausable(by: other) }
  }

  /// Error-out if `interval` time passes with no emitted elements.
  public func timeout(after interval: TimeValue, with error: ErrorType, on queue: DispatchQueue) -> Operation<Element, ErrorType> {
    return Operation { observer in
      var completed = false
      let timeoutWhenCan: () -> Disposable = {
        return queue.disposableAfter(when: interval) {
          if !completed {
            completed = true
            observer.failure(error)
          }
        }
      }
      var lastSubscription = timeoutWhenCan()
      return self.observe { event in
        lastSubscription.dispose()
        observer.observer(event)
        completed = event.isTermination
        lastSubscription = timeoutWhenCan()
      }
    }
  }
}

// MARK: Injections

extension OperationType {

  /// Updates the given subject with `true` when the receiver starts and with `false` when the receiver terminates.
  public func feedActivity<S: SubjectType>(into listener: S) -> Operation<Element, ErrorType> where S.Event.Element == Bool {
    return doOn(start: { listener.next(true) }, disposed: { listener.next(false) })
  }

  /// Updates the given subject with .Next element.
  public func feedNext<S: SubjectType>(into listener: S) -> Operation<Element, ErrorType> where S.Event.Element == Element {
    return doOn(next: { e in listener.next(e) })
  }

  /// Updates the given subject with mapped .Next element whenever the element satisfies the given constraint.
  public func feedNext<S: SubjectType>(into listener: S, when: @escaping (Element) -> Bool = { _ in true }, map: @escaping (Element) -> S.Event.Element) -> Operation<Element, ErrorType> {
    return doOn(next: { e in if when(e) { listener.next(map(e)) } })
  }

  /// Updates the given subject with error from .Failure event is such occurs.
  public func feedError<S: SubjectType>(into listener: S) -> Operation<Element, ErrorType> where S.Event.Element == ErrorType {
    return doOn(failure: { e in listener.next(e) })
  }
}

// MARK: Conditional, Boolean and Aggregational

extension OperationType {

  /// Propagate event only from an operation that starts emitting first.
  public func amb<O: OperationType>(with other: O) -> Operation<Element, ErrorType> where O.Element == Element, O.ErrorType == ErrorType {
    return lift { $0.amb(with: other.rawStream) }
  }

  /// Collect all elements into an array and emit just that array.
  public func collect() -> Operation<[Element], ErrorType> {
    return reduce([], { memo, new in memo + [new] })
  }

  /// First emit events from source and then from `other` operation.
  public func concat<O: OperationType>(with other: O) -> Operation<Element, ErrorType> where O.Element == Element, O.ErrorType == ErrorType {
    return lift { stream in
      stream.concat(with: other.rawStream)
    }
  }

  /// Emit default element is the operation completes without emitting any element.
  public func defaultIfEmpty(_ element: Element) -> Operation<Element, ErrorType> {
    return lift { $0.defaultIfEmpty(element) }
  }

  /// Reduce elements to a single element by applying given function on each emission.
  public func reduce<U>(_ initial: U, _ combine: @escaping (U, Element) -> U) -> Operation<U, ErrorType> {
    return Operation<U, ErrorType> { observer in
      observer.next(initial)
      return self.scan(initial, combine).observe(observer: observer.observer)
    }.last()
  }

  /// Par each element with its predecessor. First element is paired with `nil`.
  public func zipPrevious() -> Operation<(Element?, Element), ErrorType> {
    return Operation { observer in
      var previous: Element? = nil
      return self.observe { event in
        switch event {
        case .Next(let element):
          observer.next((previous, element))
          previous = element
        case .Failure(let error):
          observer.failure(error)
        case .Completed:
          observer.completed()
        }
      }
    }
  }
}

// MARK: Operations that emit other operation

public extension Operation where T: OperationType, T.Event: OperationEventType {
  public typealias InnerElement = T.Event.Element
  public typealias InnerError = T.Event.ErrorType

  /// Flatten the operation by observing all inner operation and propagate elements from each one as they come.
  public func merge(mapError: @escaping (ErrorType) -> InnerError) -> Operation<InnerElement, InnerError> {
    return lift {
      $0.merge(unboxEvent: { $0.unbox }, propagateErrorEvent: { event, observer in observer.failure(mapError(event.error!)) })
    }
  }

  /// Flatten the operation by observing and propagating emissions only from the latest inner operation.
  public func switchToLatest(mapError: @escaping (ErrorType) -> InnerError) -> Operation<InnerElement, InnerError> {
    return lift {
      $0.switchToLatest(unboxEvent: { $0.unbox }, propagateErrorEvent: { event, observer in observer.failure(mapError(event.error!)) })
    }
  }

  /// Flatten the operation by sequentially observing inner operations in order in
  /// which they arrive, starting next observation only after the previous one completes, cancelling previous one when new one starts.
  public func concat(mapError: @escaping (ErrorType) -> InnerError) -> Operation<InnerElement, InnerError> {
    return lift {
      $0.concat(unboxEvent: { $0.unbox }, propagateErrorEvent: { event, observer in observer.failure(mapError(event.error!)) })
    }
  }
}

public extension Operation where T: OperationType, T.Event: OperationEventType, T.Event.ErrorType == E {

  /// Flatten the operation by observing all inner operation and propagate elements from each one as they come.
  public func merge() -> Operation<InnerElement, E> {
    return merge { $0 }
  }

  /// Flatten the operation by observing and propagating emissions only from latest operation.
  public func switchToLatest() -> Operation<InnerElement, E> {
    return switchToLatest { $0 }
  }

  /// Flatten the operation by sequentially observing inner operations in order in
  /// which they arrive, starting next observation only after previous one completes.
  public func concat() -> Operation<InnerElement, E> {
    return concat { $0 }
  }
}

// MARK: Connectable

extension OperationType {

  /// Ensure that all observers see the same sequence of elements. Connectable.
  public func replay(_ limit: Int = Int.max) -> ConnectableOperation<Element, ErrorType> {
    return ConnectableOperation(rawConnectableStream: rawStream.replay(limit))
  }

  /// Convert the operation to a connectable operation.
  public func publish() -> ConnectableOperation<Element, ErrorType> {
    return ConnectableOperation(rawConnectableStream: rawStream.publish())
  }

  /// Ensure that all observers see the same sequence of elements.
  /// Shorthand for `replay(limit).refCount()`.
  public func shareReplay(_ limit: Int = Int.max) -> Operation<Element, ErrorType> {
    return replay(limit).refCount()
  }
}

// MARK: Functions

/// Combine multiple operations into one. See `mergeWith` for more info.
public func combineLatest
  <A: OperationType,
   B: OperationType>
  (_ a: A, _ b: B) -> Operation<(A.Element, B.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType {
  return a.combineLatest(with: b)
}

/// Combine multiple operations into one. See `mergeWith` for more info.
public func combineLatest
  <A: OperationType,
   B: OperationType,
   C: OperationType>
  (_ a: A, _ b: B, _ c: C) -> Operation<(A.Element, B.Element, C.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType,
  A.ErrorType == C.ErrorType {
  return combineLatest(a, b).combineLatest(with: c).map { ($0.0, $0.1, $1) }
}

/// Combine multiple operations into one. See `mergeWith` for more info.
public func combineLatest
  <A: OperationType,
   B: OperationType,
   C: OperationType,
   D: OperationType>
  (_ a: A, _ b: B, _ c: C, _ d: D) -> Operation<(A.Element, B.Element, C.Element, D.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType,
  A.ErrorType == C.ErrorType,
  A.ErrorType == D.ErrorType {
  return combineLatest(a, b, c).combineLatest(with: d).map { ($0.0, $0.1, $0.2, $1) }
}

/// Combine multiple operations into one. See `mergeWith` for more info.
public func combineLatest
  <A: OperationType,
   B: OperationType,
   C: OperationType,
   D: OperationType,
   E: OperationType>
  (_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Operation<(A.Element, B.Element, C.Element, D.Element, E.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType,
  A.ErrorType == C.ErrorType,
  A.ErrorType == D.ErrorType,
  A.ErrorType == E.ErrorType {
  return combineLatest(a, b, c, d).combineLatest(with: e).map { ($0.0, $0.1, $0.2, $0.3, $1) }
}

/// Combine multiple operations into one. See `mergeWith` for more info.
public func combineLatest
  <A: OperationType,
   B: OperationType,
   C: OperationType,
   D: OperationType,
   E: OperationType,
   F: OperationType>
  (_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Operation<(A.Element, B.Element, C.Element, D.Element, E.Element, F.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType,
  A.ErrorType == C.ErrorType,
  A.ErrorType == D.ErrorType,
  A.ErrorType == E.ErrorType,
  A.ErrorType == F.ErrorType {
  return combineLatest(a, b, c, d, e).combineLatest(with: f).map { ($0.0, $0.1, $0.2, $0.3, $0.4, $1) }
}

/// Zip multiple operations into one. See `zipWith` for more info.
public func zip
  <A: OperationType,
   B: OperationType>
  (_ a: A, _ b: B) -> Operation<(A.Element, B.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType {
  return a.zip(with: b)
}

/// Zip multiple operations into one. See `zipWith` for more info.
public func zip
  <A: OperationType,
   B: OperationType,
   C: OperationType>
  (_ a: A, _ b: B, _ c: C) -> Operation<(A.Element, B.Element, C.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType,
  A.ErrorType == C.ErrorType {
  return zip(a, b).zip(with: c).map { ($0.0, $0.1, $1) }
}

/// Zip multiple operations into one. See `zipWith` for more info.
public func zip
  <A: OperationType,
   B: OperationType,
   C: OperationType,
   D: OperationType>
  (_ a: A, _ b: B, _ c: C, _ d: D) -> Operation<(A.Element, B.Element, C.Element, D.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType,
  A.ErrorType == C.ErrorType,
  A.ErrorType == D.ErrorType {
  return zip(a, b, c).zip(with: d).map { ($0.0, $0.1, $0.2, $1) }
}

/// Zip multiple operations into one. See `zipWith` for more info.
public func zip
  <A: OperationType,
   B: OperationType,
   C: OperationType,
   D: OperationType,
   E: OperationType>
  (_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> Operation<(A.Element, B.Element, C.Element, D.Element, E.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType,
  A.ErrorType == C.ErrorType,
  A.ErrorType == D.ErrorType,
  A.ErrorType == E.ErrorType {
  return zip(a, b, c, d).zip(with: e).map { ($0.0, $0.1, $0.2, $0.3, $1) }
}

/// Zip multiple operations into one. See `zipWith` for more info.
public func zip
  <A: OperationType,
   B: OperationType,
   C: OperationType,
   D: OperationType,
   E: OperationType,
   F: OperationType>
  (_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> Operation<(A.Element, B.Element, C.Element, D.Element, E.Element, F.Element), A.ErrorType> where
  A.ErrorType == B.ErrorType,
  A.ErrorType == C.ErrorType,
  A.ErrorType == D.ErrorType,
  A.ErrorType == E.ErrorType,
  A.ErrorType == F.ErrorType {
  return zip(a, b, c, d, e).zip(with: f).map { ($0.0, $0.1, $0.2, $0.3, $0.4, $1) }
}

// MARK: - ConnectableOperation

/// Represents an operation that is started by calling `connect` on it.
public class ConnectableOperation<T, E: Error>: OperationType, ConnectableStreamType {
  public typealias Event = OperationEvent<T, E>

  fileprivate let rawConnectableStream: RawConnectableStream<RawStream<Event>>

  public var rawStream: RawStream<OperationEvent<T, E>> {
    return rawConnectableStream.toRawStream()
  }

  fileprivate init(rawConnectableStream: RawConnectableStream<RawStream<Event>>) {
    self.rawConnectableStream = rawConnectableStream
  }

  /// Register an observer that will receive events from the operation.
  /// Note that the events will not be generated until `connect` is called.
  public func observe(observer: @escaping (Event) -> Void) -> Disposable {
    return rawConnectableStream.observe(observer: observer)
  }

  /// Start the operation.
  public func connect() -> Disposable {
    return rawConnectableStream.connect()
  }
}

public extension ConnectableOperation {

  /// Convert connectable operation into the ordinary one by calling `connect`
  /// on first subscription and calling dispose when number of observers goes down to zero.
  public func refCount() -> Operation<T, E> {
    return Operation(rawStream: self.rawConnectableStream.refCount())
  }
}

// MARK: - PushOperation

/// Represents an operation that can push events to registered observers at will.
public class PushOperation<T, E: Error>: OperationType, SubjectType {
  fileprivate let subject = PublishSubject<OperationEvent<T, E>>()

  public var rawStream: RawStream<OperationEvent<T, E>> {
    return subject.toRawStream()
  }

  public init() {
  }

  /// Send event to all registered observers.
  public func on(_ event: OperationEvent<T, E>) {
    subject.on(event)
  }
}

extension PushOperation {

  /// Convert `PushOperation` to ordinary `Operation`.
  public func toOperation() -> Operation<T, E> {
    return Operation(rawStream: rawStream)
  }
}

// MARK: - Other

public enum FlatMapStrategy {

  /// Use `switchToLatest` flattening method.
  case Latest

  /// Use `merge` flattening method.
  case Merge

  /// Use `concat` flattening method.
  case Concat
}
