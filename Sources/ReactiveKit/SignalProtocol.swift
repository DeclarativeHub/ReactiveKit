//
//  The MIT License (MIT)
//
//  Copyright (c) 2016 Srdan Rasic (@srdanrasic)
//
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//

import Dispatch
import Foundation

// MARK: - SignalProtocol

/// Represents a sequence of events.
public protocol SignalProtocol {

  /// The type of elements generated by the signal.
  associatedtype Element

  /// The type of error that can terminate the signal.
  associatedtype Error: Swift.Error

  /// Register the given observer.
  /// - Parameter observer: A function that will receive events.
  /// - Returns: A disposable that can be used to cancel the observation.
  func observe(with observer: @escaping Observer<Element, Error>) -> Disposable
}

extension SignalProtocol {

  /// Register an observer that will receive events from a signal.
  public func observe<O: ObserverProtocol>(with observer: O) -> Disposable
    where O.Element == Element, O.Error == Error {
    return observe(with: observer.on)
  }

  /// Register an observer that will receive elements from `.next` events of the signal.
  public func observeNext(with observer: @escaping (Element) -> Void) -> Disposable {
    return observe { event in
      if case .next(let element) = event {
        observer(element)
      }
    }
  }

  /// Register an observer that will receive elements from `.failed` events of the signal.
  public func observeFailed(with observer: @escaping (Error) -> Void) -> Disposable {
    return observe { event in
      if case .failed(let error) = event {
        observer(error)
      }
    }
  }

  /// Register an observer that will be executed on `.completed` event.
  public func observeCompleted(with observer: @escaping () -> Void) -> Disposable {
    return observe { event in
      if case .completed = event {
        observer()
      }
    }
  }
}

// MARK: - Extensions

// MARK: Creating a signal

public extension SignalProtocol {

  /// Create a signal that emits given element and then completes.
  public static func just(_ element: Element) -> Signal<Element, Error> {
    return Signal { observer in
      observer.next(element)
      observer.completed()
      return NonDisposable.instance
    }
  }

  /// Create a signal that emits given sequence of elements and then completes.
  public static func sequence<S: Sequence>(_ sequence: S) -> Signal<Element, Error> where S.Iterator.Element == Element {
    return Signal { observer in
      sequence.forEach(observer.next)
      observer.completed()
      return NonDisposable.instance
    }
  }

  /// Create a signal that completes without emitting any elements.
  public static func completed() -> Signal<Element, Error> {
    return Signal { observer in
      observer.completed()
      return NonDisposable.instance
    }
  }

  /// Create a signal that just terminates with the given error.
  public static func failed(_ error: Error) -> Signal<Element, Error> {
    return Signal { observer in
      observer.failed(error)
      return NonDisposable.instance
    }
  }

  /// Create a signal that never completes.
  public static func never() -> Signal<Element, Error> {
    return Signal { observer in
      return NonDisposable.instance
    }
  }

  /// Create a signal that emits an integer every `interval` time on a given dispatch queue.
  public static func interval(_ interval: Double, queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.interval")) -> Signal<Int, Error> {
    return Signal { observer in
      var number = 0
      var dispatch: (() -> Void)!
      let disposable = SimpleDisposable()
      dispatch = {
        queue.after(when: interval) {
          guard !disposable.isDisposed else { dispatch = nil; return }
          observer.next(number)
          number = number + 1
          dispatch()
        }
      }
      dispatch()
      return disposable
    }
  }

  /// Create a signal that emits given element after `time` time on a given queue.
  public static func timer(element: Element, time: Double, queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.timer")) -> Signal<Element, Error> {
    return Signal { observer in
      let disposable = SimpleDisposable()
      queue.after(when: time) {
        guard !disposable.isDisposed else { return }
        observer.next(element)
        observer.completed()
      }
      return disposable
    }
  }
}

// MARK: Transforming signals

public extension SignalProtocol {

  /// Batch the elements into arrays of given size.
  public func buffer(size: Int) -> Signal<[Element], Error> {
    return Signal { observer in
      var buffer: [Element] = []
      return self.observe { event in
        switch event {
        case .next(let element):
          buffer.append(element)
          if buffer.count == size {
            observer.next(buffer)
            buffer.removeAll()
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Maps each element into an optional type and propagates unwrapped .some results.
  /// Shorthand for ```map().ignoreNil()```.
  public func flatMap<U>(_ transform: @escaping (Element) -> U?) -> Signal<U, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          if let element = transform(element) {
            observer.next(element)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapLatest<O: SignalProtocol>(_ transform: @escaping (Element) -> O) -> Signal<O.Element, Error> where O.Error == Error {
    return map(transform).switchToLatest()
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapMerge<O: SignalProtocol>(_ transform: @escaping (Element) -> O) -> Signal<O.Element, Error> where O.Error == Error {
    return map(transform).merge()
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapConcat<O: SignalProtocol>(_ transform: @escaping (Element) -> O) -> Signal<O.Element, Error> where O.Error == Error {
    return map(transform).concat()
  }

  /// Map failure event into another operation and continue with that operation. Also called `catch`.
  public func flatMapError<S: SignalProtocol>(_ recover: @escaping (Error) -> S) -> Signal<Element, S.Error> where S.Element == Element {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)

      serialDisposable.otherDisposable = self.observe { taskEvent in
        switch taskEvent {
        case .next(let value):
          observer.next(value)
        case .completed:
          observer.completed()
        case .failed(let error):
          serialDisposable.otherDisposable = recover(error).observe(with: observer.on)
        }
      }

      return serialDisposable
    }
  }

  /// Transform each element by applying `transform` on it.
  public func map<U>(_ transform: @escaping (Element) -> U) -> Signal<U, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          observer.next(transform(element))
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Transform error by applying `transform` on it.
  public func mapError<F>(_ transform: @escaping (Error) -> F) -> Signal<Element, F> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          observer.next(element)
        case .failed(let error):
          observer.failed(transform(error))
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Replace all emitted elements with the given element.
  public func replace<T>(with element: T) -> Signal<T, Error> {
    return map { _ in element }
  }

  /// Map elements to Void.
  public func eraseType() -> Signal<Void, Error> {
    return map { _ in }
  }

  /// Apply `combine` to each element starting with `initial` and emit each
  /// intermediate result. This differs from `reduce` which emits only final result.
  public func scan<U>(_ initial: U, _ combine: @escaping (U, Element) -> U) -> Signal<U, Error> {
    return Signal { observer in
      var accumulator = initial
      observer.next(accumulator)
      return self.observe { event in
        switch event {
        case .next(let element):
          accumulator = combine(accumulator, element)
          observer.next(accumulator)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Transform each element by applying `transform` on it.
  public func tryMap<U>(_ transform: @escaping (Element) -> Result<U, Error>) -> Signal<U, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          switch transform(element) {
          case .success(let value):
            observer.next(value)
          case .failure(let error):
            observer.failed(error)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Convert the receiver to a concrete signal.
  public func toSignal() -> Signal<Element, Error> {
    if let signal = self as? Signal<Element, Error> {
      return signal
    } else {
      return Signal { observer in
        return self.observe(with: observer.on)
      }
    }
  }

  /// Branches out error into another signal.
  public func branchOutError() -> (Signal<Element, NoError>, Signal<Error, NoError>) {
    let shared = shareReplay()
    return (shared.suppressError(logging: false), shared.toErrorSignal())
  }

  /// Branches out mapped error into another signal.
  public func branchOutError<F>(_ mapError: @escaping (Error) -> F) -> (Signal<Element, NoError>, Signal<F, NoError>) {
    let shared = shareReplay()
    return (shared.suppressError(logging: false), shared.toErrorSignal().map(mapError))
  }

  /// Converts signal into non-failable signal by suppressing the error.
  public func suppressError(logging: Bool, file: String = #file, line: Int = #line) -> Signal<Element, NoError> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          observer.next(element)
        case .failed(let error):
          observer.completed()
          if logging {
            print("Signal at \(file):\(line) encountered an error: \(error)")
          }
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Converts signal into non-failable signal by feeding suppressed error into a subject.
  public func suppressAndFeedError<S: SubjectProtocol>(into listener: S, logging: Bool = true, file: String = #file, line: Int = #line) -> Signal<Element, NoError> where S.Element == Error {
    return feedError(into: listener).suppressError(logging: logging, file: file, line: line)
  }

  /// Recovers the signal by propagating default element if error happens.
  public func recover(with element: Element) -> Signal<Element, NoError> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          observer.next(element)
        case .failed:
          observer.next(element)
          observer.completed()
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Maps failable signal into a non-failable signal of errors. Ignores `.next` events.
  public func toErrorSignal() -> Signal<Error, NoError> {
    return Signal { observer in
      return self.observe { taskEvent in
        switch taskEvent {
        case .next:
          break
        case .completed:
          observer.completed()
        case .failed(let error):
          observer.next(error)
        }
      }
    }
  }

  /// Batch each `size` elements into another signal.
  public func window(size: Int) -> Signal<Signal<Element, Error>, Error> {
    return buffer(size: size).map { Signal.sequence($0) }
  }
}

extension SignalProtocol where Element: OptionalProtocol {

  /// Apply `transform` to all non-nil elements.
  public func flatMap<U>(_ transform: @escaping (Element.Wrapped) -> U?) -> Signal<U?, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          if let element = element._unbox {
            observer.next(transform(element))
          } else {
            observer.next(nil)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }
}

extension SignalProtocol where Element: Sequence {

  /// Map each emitted sequence.
  public func flatMap<U>(_ transform: @escaping (Element.Iterator.Element) -> U) -> Signal<[U], Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          observer.next(element.map(transform))
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Unwraps elements from each emitted sequence into an events of their own.
  public func unwrap() -> Signal<Element.Iterator.Element, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let sequence):
          sequence.forEach(observer.next)
        case .completed:
          observer.completed()
        case .failed(let error):
          observer.failed(error)
        }
      }
    }
  }
}

// MARK: Filtering signals

public extension SignalProtocol {

  /// Emit an element only if `interval` time passes without emitting another element.
  public func debounce(interval: Double, on queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.debounce")) -> Signal<Element, Error> {
    return Signal { observer in
      var timerSubscription: Disposable? = nil
      var previousElement: Element? = nil
      return self.observe { event in
        timerSubscription?.dispose()
        switch event {
        case .next(let element):
          previousElement = element
          timerSubscription = queue.disposableAfter(when: interval) {
            if let _element = previousElement {
              observer.next(_element)
              previousElement = nil
            }
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          if let previousElement = previousElement {
            observer.next(previousElement)
            observer.completed()
          }
        }

      }
    }
  }

  /// Emit first element and then all elements that are not equal to their predecessor(s).
  public func distinct(areDistinct: @escaping (Element, Element) -> Bool) -> Signal<Element, Error> {
    return Signal { observer in
      var lastElement: Element? = nil
      return self.observe { event in
        switch event {
        case .next(let element):
          let prevLastElement = lastElement
          lastElement = element
          if prevLastElement == nil || areDistinct(prevLastElement!, element) {
            observer.next(element)
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Emit only element at given index if such element is produced.
  public func element(at index: Int) -> Signal<Element, Error> {
    return Signal { observer in
      var currentIndex = 0
      return self.observe { event in
        switch event {
        case .next(let element):
          if currentIndex == index {
            observer.next(element)
            observer.completed()
          } else {
            currentIndex += 1
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Emit only elements that pass `include` test.
  public func filter(_ isIncluded: @escaping (Element) -> Bool) -> Signal<Element, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          if isIncluded(element) {
            observer.next(element)
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Filters the signal by executing `isIncluded` in each element and
  /// propagates that element only if the returned signal fires `true`.
  public func filter(_ isIncluded: @escaping (Element) -> SafeSignal<Bool>) -> Signal<Element, Error> {
    return flatMapLatest { element -> Signal<Element, Error> in
      return isIncluded(element)
        .first()
        .map { isIncluded -> Element? in
          if isIncluded {
            return element
          } else {
            return nil
          }
        }
        .ignoreNil()
        .castError()
    }
  }

  /// Emit only the first element generated by the signal and then complete.
  public func first() -> Signal<Element, Error> {
    return take(first: 1)
  }

  /// Ignore all elements (just propagate terminal events).
  public func ignoreElements() -> Signal<Element, Error> {
    return filter { _ in false }
  }
  
  /// Ignore all terminal events (just propagate next events).
  public func ignoreTerminal() -> Signal<Element, Error> {
    return Signal { observer in
      return self.observe { event in
        if case .next(let element) = event {
          observer.next(element)
        }
      }
    }
  }

  /// Emit only last element generated by the signal and then complete.
  public func last() -> Signal<Element, Error> {
    return take(last: 1)
  }

  /// Periodically sample the signal and emit latest element from each interval.
  public func sample(interval: Double, on queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.sample")) -> Signal<Element, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      var latestElement: Element? = nil
      var dispatch: (() -> Void)!
      dispatch = {
        queue.after(when: interval) {
          guard !serialDisposable.isDisposed else { dispatch = nil; return }
          if let element = latestElement {
            observer.next(element)
            latestElement = nil
          }
          dispatch()
        }
      }

      serialDisposable.otherDisposable = self.observe { event in
        switch event {
        case .next(let element):
          latestElement = element
        default:
          observer.on(event)
          serialDisposable.dispose()
        }
      }

      dispatch()
      return serialDisposable
    }
  }

  /// Suppress first `count` elements generated by the signal.
  public func skip(first count: Int) -> Signal<Element, Error> {
    return Signal { observer in
      var count = count
      return self.observe { event in
        switch event {
        case .next(let element):
          if count > 0 {
            count -= 1
          } else {
            observer.next(element)
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Suppress last `count` elements generated by the signal.
  public func skip(last count: Int) -> Signal<Element, Error> {
    guard count > 0 else { return self.toSignal() }
    return Signal { observer in
      var buffer: [Element] = []
      return self.observe { event in
        switch event {
        case .next(let element):
          buffer.append(element)
          if buffer.count > count {
            observer.next(buffer.removeFirst())
          }
        default:
          observer.on(event)
        }
      }
    }
  }

  /// Suppress elements for first `interval` seconds.
  public func skip(interval: Double) -> Signal<Element, Error> {
    return Signal { observer in
      let startTime = Date().addingTimeInterval(interval)
      return self.observe { event in
        switch event {
        case .next:
          if startTime < Date() {
            observer.on(event)
          }
        case .completed, .failed:
          observer.on(event)
        }
      }
    }
  }

  /// Emit only first `count` elements of the signal and then complete.
  public func take(first count: Int) -> Signal<Element, Error> {
    return Signal { observer in
      guard count > 0 else {
        observer.completed()
        return NonDisposable.instance
      }

      var taken = 0

      let serialDisposable = SerialDisposable(otherDisposable: nil)
      serialDisposable.otherDisposable = self.observe { event in
        switch event {
        case .next(let element):
          if taken < count {
            taken += 1
            observer.next(element)
          }
          if taken == count {
            observer.completed()
            serialDisposable.otherDisposable?.dispose()
          }
        default:
          observer.on(event)
        }
      }
      return serialDisposable
    }
  }

  /// Emit only last `count` elements of the signal and then complete.
  public func take(last count: Int) -> Signal<Element, Error> {
    return Signal { observer in
      var values: [Element] = []
      values.reserveCapacity(count)
      return self.observe(with: { (event) in
        switch event {
        case .completed:
          values.forEach(observer.next)
          observer.completed()
        case .failed(let error):
          observer.failed(error)
        case .next(let element):
          if event.isTerminal {
            observer.on(event)
          } else {
            if values.count + 1 > count {
              values.removeFirst(values.count - count + 1)
            }
            values.append(element)
          }
        }
      })
    }
  }

  /// Emit elements of the reciver until given signal completes and then complete the receiver.
  public func take<S: SignalProtocol>(until signal: S) -> Signal<Element, Error> {
    return Signal { observer in
      let disposable = CompositeDisposable()

      disposable += signal.observe { event in
        observer.completed()
      }

      disposable += self.observe { event in
        switch event {
        case .completed:
          observer.completed()
        case .failed(let error):
          observer.failed(error)
        case .next(let element):
          observer.next(element)
        }
      }

      return disposable
    }
  }

  /// Throttle the signal to emit at most one element per given `seconds` interval.
  public func throttle(seconds: Double) -> Signal<Element, Error> {
    return Signal { observer in
      var lastEventTime: DispatchTime?
      return self.observe { event in
        switch event {
        case .next(let element):
          let now = DispatchTime.now()
          if lastEventTime == nil || now.rawValue > (lastEventTime! + seconds).rawValue {
            lastEventTime = now
            observer.next(element)
          }
        default:
          observer.on(event)
        }
      }
    }
  }
}

public extension SignalProtocol where Element: Equatable {

  /// Emit first element and then all elements that are not equal to their predecessor(s).
  public func distinct() -> Signal<Element, Error> {
    return distinct(areDistinct: !=)
  }
}

public extension SignalProtocol where Element: OptionalProtocol, Element.Wrapped: Equatable {
  
  /// Emit first element and then all elements that are not equal to their predecessor(s).
  public func distinct() -> Signal<Element, Error> {
    return distinct(areDistinct: !=)
  }
}

public extension SignalProtocol where Element: OptionalProtocol {

  /// Suppress all `nil`-elements.
  public func ignoreNil() -> Signal<Element.Wrapped, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          if let element = element._unbox {
            observer.next(element)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Replace all `nil`-elements with the provided replacement.
  public func replaceNil(with replacement: Element.Wrapped) -> Signal<Element.Wrapped, Error> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          if let element = element._unbox {
            observer.next(element)
          } else {
            observer.next(replacement)
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }
}

//  MARK: Utilities

extension SignalProtocol {

  /// Set the execution context in which to execute the signal (i.e. in which to run
  /// the signal's producer).
  public func executeIn(_ context: ExecutionContext) -> Signal<Element, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      context.execute {
        if !serialDisposable.isDisposed {
          serialDisposable.otherDisposable = self.observe(with: observer.on)
        }
      }
      return serialDisposable
    }
  }

  /// Set the dispatch queue on which to execute the signal (i.e. in which to run
  /// the signal's producer).
  public func executeOn(_ queue: DispatchQueue) -> Signal<Element, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      queue.async {
        if !serialDisposable.isDisposed {
          serialDisposable.otherDisposable = self.observe(with: observer.on)
        }
      }
      return serialDisposable
    }
  }

  /// Delay signal events for `interval` time.
  public func delay(interval: Double, on queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.delay")) -> Signal<Element, Error> {
    return Signal { observer in
      return self.observe { event in
        queue.after(when: interval) {
          observer.on(event)
        }
      }
    }
  }

  /// Do side-effect upon various events.
  public func doOn(next: ((Element) -> ())? = nil,
                   start: (() -> Void)? = nil,
                   failed: ((Error) -> Void)? = nil,
                   completed: (() -> Void)? = nil,
                   disposed: (() -> ())? = nil) -> Signal<Element, Error> {
    return Signal { observer in
      start?()
      let disposable = self.observe { event in
        switch event {
        case .next(let value):
          next?(value)
        case .failed(let error):
          failed?(error)
        case .completed:
          completed?()
        }
        observer.on(event)
      }
      return BlockDisposable {
        disposable.dispose()
        disposed?()
      }
    }
  }

  /// Log various signal events. If title is not provided, source file and function names are printed instead.
  public func debug(_ title: String? = nil, file: String = #file, function: String = #function, line: Int = #line) -> Signal<Element, Error> {
    let prefix: String
    if let title = title {
      prefix = "[\(title)]"
    } else {
      let filename = file.components(separatedBy: "/").last ?? file
      prefix = "[\(filename):\(function):\(line)]"
    }

    return doOn(next: { element in
        print("\(prefix) next(\(element))")
      }, start: {
        print("\(prefix) started")
      }, failed: { error in
        print("\(prefix) failed: \(error)")
      }, completed: {
        print("\(prefix) completed")
      }, disposed: {
        print("\(prefix) disposed")
    })
  }

  /// Set the execution context used to dispatch events (i.e. to run the observers).
  public func observeIn(_ context: ExecutionContext) -> Signal<Element, Error> {
    return Signal { observer in
      return self.observe { event in
        context.execute {
          observer.on(event)
        }
      }
    }
  }

  /// Set the dispatch queue used to dispatch events (i.e. to run the observers).
  public func observeOn(_ queue: DispatchQueue) -> Signal<Element, Error> {
    return Signal { observer in
      return self.observe { event in
        queue.async {
          observer.on(event)
        }
      }
    }
  }

  /// Supress events while last event generated on other signal is `false`.
  public func pausable<O: SignalProtocol>(by: O) -> Signal<Element, Error> where O.Element == Bool {
    return Signal { observer in
      var allowed: Bool = true
      let compositeDisposable = CompositeDisposable()

      compositeDisposable += by.observeNext { value in
        allowed = value
      }

      compositeDisposable += self.observe { event in
        if event.isTerminal || allowed {
          observer.on(event)
        }
      }

      return compositeDisposable
    }
  }

  /// Restart the operation in case of failure at most `times` number of times.
  public func retry(times: Int) -> Signal<Element, Error> {
    guard times > 0 else { return toSignal() }

    return Signal { observer in
      var remainingAttempts = times
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      var attempt: (() -> Void)?
      attempt = {
        serialDisposable.otherDisposable?.dispose()
        serialDisposable.otherDisposable = self.observe { event in
          switch event {
          case .next(let element):
            observer.next(element)
          case .failed(let error):
            if remainingAttempts > 0 {
              remainingAttempts -= 1
              attempt?()
            } else {
              attempt = nil
              observer.failed(error)
            }
          case .completed:
            attempt = nil
            observer.completed()
          }
        }
      }
      attempt?()
      return BlockDisposable {
        serialDisposable.dispose()
        attempt = nil
      }
    }
  }

  /// Retries the failed signal when other signal produces an element.
  public func retry<S: SignalProtocol>(when other: S) -> Signal<Element, Error> where S.Error == NoError {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      var attempt: (() -> Void)?
      attempt = {
        serialDisposable.otherDisposable?.dispose()
        let compositeDisposable = CompositeDisposable()
        serialDisposable.otherDisposable = compositeDisposable
        compositeDisposable += self.observe { event in
          switch event {
          case .next(let element):
            observer.next(element)
          case .completed:
            attempt = nil
            observer.completed()
          case .failed(let error):
            compositeDisposable += other.observe { otherEvent in
              switch otherEvent {
              case .next:
                attempt?()
              case .completed, .failed:
                attempt = nil
                observer.failed(error)
              }
            }
          }
        }
      }
      attempt?()
      return serialDisposable
    }
  }

  /// Error-out if `interval` time passes with no emitted elements.
  public func timeout(after interval: Double, with error: Error, on queue: DispatchQueue = DispatchQueue(label: "com.reactivekit.timeout")) -> Signal<Element, Error> {
    return Signal { observer in
      var completed = false
      let timeoutWhenCan: () -> Disposable = {
        return queue.disposableAfter(when: interval) {
          if !completed {
            completed = true
            observer.failed(error)
          }
        }
      }
      var lastSubscription = timeoutWhenCan()
      return self.observe { event in
        lastSubscription.dispose()
        observer.on(event)
        completed = event.isTerminal
        lastSubscription = timeoutWhenCan()
      }
    }
  }

  /// Collect all elements into an array and emit just that array.
  public func collect() -> Signal<[Element], Error> {
    return reduce([], { memo, new in memo + [new] })
  }

  /// First emit events from source and then from `other` signal.
  public func concat(with other: Signal<Element, Error>) -> Signal<Element, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      serialDisposable.otherDisposable = self.observe { event in
        switch event {
        case .next(let element):
          observer.next(element)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          serialDisposable.otherDisposable = other.observe(with: observer.on)
        }
      }
      return serialDisposable
    }
  }

  /// Emit default element if signal completes without emitting any element.
  public func defaultIfEmpty(_ element: Element) -> Signal<Element, Error> {
    return Signal { observer in
      var didEmitNonTerminal = false
      return self.observe { event in
        switch event {
        case .next(let element):
          didEmitNonTerminal = true
          observer.next(element)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          if !didEmitNonTerminal {
            observer.next(element)
          }
          observer.completed()
        }
      }
    }
  }

  /// Reduce signal events to a single event by applying given function on each emission.
  public func reduce<U>(_ initial: U, _ combine: @escaping (U, Element) -> U) -> Signal<U, Error> {
    return scan(initial, combine).take(last: 1)
  }

  /// Replays the latest element when other signal fires an element.
  public func replayLatest<S: SignalProtocol>(when other: S) -> Signal<Element, Error> where S.Error == NoError {
    return Signal { observer in
      var latest: Element? = nil
      let disposable = CompositeDisposable()

      disposable += other.observe { event in
        switch event {
        case .next:
          if let latest = latest {
            observer.next(latest)
          }
        case .failed, .completed:
          break
        }
      }

      disposable += self.observe { event in
        switch event {
        case .next(let element):
          latest = element
          observer.next(element)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }

      return disposable
    }
  }

  /// Prepend the given element to the signal emission.
  public func start(with element: Element) -> Signal<Element, Error> {
    return Signal { observer in
      observer.next(element)
      return self.observe { event in
        observer.on(event)
      }
    }
  }

  /// Par each element with its predecessor. First element is paired with `nil`.
  public func zipPrevious() -> Signal<(Element?, Element), Error> {
    return Signal { observer in
      var previous: Element? = nil
      return self.observe { event in
        switch event {
        case .next(let element):
          let lastPrevious = previous
          previous = element
          observer.next((lastPrevious, element))
        case .failed(let error):
          observer.failed(error)
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Wrap events into elements.
  public func materialize() -> Signal<Event<Element, Error>, NoError> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          observer.next(.next(element))
        case .failed(let error):
          observer.next(.failed(error))
          observer.completed()
        case .completed:
          observer.next(.completed)
          observer.completed()
        }
      }
    }
  }
}

// MARK: Injections

extension SignalProtocol {

  /// Update the given subject with `true` when the receiver starts and with `false` when the receiver terminates.
  public func feedActivity<S: SubjectProtocol>(into listener: S) -> Signal<Element, Error> where S.Element == Bool {
    return doOn(start: { listener.next(true) }, disposed: { listener.next(false) })
  }

  /// Update the given subject with `.next` elements.
  public func feedNext<S: SubjectProtocol>(into listener: S) -> Signal<Element, Error> where S.Element == Element {
    return doOn(next: { e in listener.next(e) })
  }

  /// Update the given subject with mapped `.next` element whenever the element satisfies the given constraint.
  public func feedNext<S: SubjectProtocol>(into listener: S, when: @escaping (Element) -> Bool = { _ in true }, map: @escaping (Element) -> S.Element) -> Signal<Element, Error> {
    return doOn(next: { e in if when(e) { listener.next(map(e)) } })
  }

  /// Updates the given subject with error from .failed event is such occurs.
  public func feedError<S: SubjectProtocol>(into listener: S) -> Signal<Element, Error> where S.Element == Error {
    return doOn(failed: { e in listener.next(e) })
  }
}

// MARK: Signals that emit other signals

public extension SignalProtocol where Element: SignalProtocol, Element.Error == Error {

  public typealias InnerElement = Element.Element

  /// Flatten the signal by observing all inner signals and propagate events from each one as they come.
  public func merge() -> Signal<InnerElement, Error> {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "com.reactivekit.merge")
      let compositeDisposable = CompositeDisposable()
      var numberOfOperations = 1 // 1 for outer signal

      func decrementNumberOfOperations() {
          numberOfOperations -= 1
          if numberOfOperations == 0 {
            observer.completed()
          }
      }

      compositeDisposable += self.observe { outerEvent in
        switch outerEvent {
        case .next(let innerSignal):
          lock.lock()
          numberOfOperations += 1
          compositeDisposable += innerSignal.observe { innerEvent in
            switch innerEvent {
            case .next(let element):
              observer.next(element)
            case .failed(let error):
              observer.failed(error)
            case .completed:
              decrementNumberOfOperations()
            }
          }
          lock.unlock()
        case .failed(let error):
          observer.failed(error)
        case .completed:
          lock.lock()
          decrementNumberOfOperations()
          lock.unlock()
        }
      }

      return compositeDisposable
    }
  }

  /// Flatten the signal by observing and propagating emissions only from latest signal.
  public func switchToLatest() -> Signal<InnerElement, Error> {
    return Signal { observer in
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      let compositeDisposable = CompositeDisposable([serialDisposable])
      var completions = (outer: false, inner: false)
      let lock = NSRecursiveLock(name: "com.reactivekit.switchtolatest")

      compositeDisposable += self.observe { outerEvent in
        switch outerEvent {
        case .next(let innerSignal):
          lock.lock()
          completions.inner = false
          serialDisposable.otherDisposable?.dispose()
          serialDisposable.otherDisposable = innerSignal.observe { innerEvent in
            switch innerEvent {
            case .next(let element):
              observer.next(element)
            case .failed(let error):
              observer.failed(error)
            case .completed:
              lock.lock()
              completions.inner = true
              if completions.outer {
                observer.completed()
              }
              lock.unlock()
            }
          }
          lock.unlock()
        case .failed(let error):
          observer.failed(error)
        case .completed:
          lock.lock()
          completions.outer = true
          if completions.inner {
            observer.completed()
          }
          lock.unlock()
        }
      }

      return compositeDisposable
    }
  }

  /// Flatten the signal by sequentially observing inner signals in order in which they
  /// arrive, starting next observation only after previous one completes.
  public func concat() -> Signal<InnerElement, Error> {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "com.reactivekit.concat")
      let serialDisposable = SerialDisposable(otherDisposable: nil)
      let compositeDisposable = CompositeDisposable([serialDisposable])
      var completions = (outer: false, inner: true)
      var innerSignalQueue: [Element] = []

      func startNextOperation() {
        completions.inner = false

        let innerSignal = innerSignalQueue.removeFirst()

        serialDisposable.otherDisposable?.dispose()
        serialDisposable.otherDisposable = innerSignal.observe { event in
          switch event {
          case .next(let element):
            observer.next(element)
          case .failed(let error):
            observer.failed(error)
          case .completed:
            lock.lock()
            completions.inner = true
            if !innerSignalQueue.isEmpty {
              startNextOperation()
            } else if completions.outer {
              observer.completed()
            }
            lock.unlock()
          }
        }
      }

      func addToQueue(signal: Element) {
        lock.lock()
        innerSignalQueue.append(signal)
        if completions.inner {
          startNextOperation()
        }
        lock.unlock()
      }

      compositeDisposable += self.observe { outerEvent in
        switch outerEvent {
        case .next(let innerSignal):
          addToQueue(signal: innerSignal)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          lock.lock()
          completions.outer = true
          if completions.inner {
            observer.completed()
          }
          lock.unlock()
        }
      }
      
      return compositeDisposable
    }
  }
}

// MARK: Combinational

extension SignalProtocol {

  fileprivate func _amb<O: SignalProtocol>(with other: O) -> Signal<Element, Error> where O.Element == Element, O.Error == Error {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "com.reactivekit.amb")
      let disposable = (my: SerialDisposable(otherDisposable: nil), other: SerialDisposable(otherDisposable: nil))
      var dispatching = (me: false, other: false)

      disposable.my.otherDisposable = self.observe { event in
        lock.lock(); defer { lock.unlock() }
        guard !dispatching.other else { return }
        dispatching.me = true
        observer.on(event)
        if !disposable.other.isDisposed {
          disposable.other.dispose()
        }
      }

      disposable.other.otherDisposable = other.observe { event in
        lock.lock(); defer { lock.unlock() }
        guard !dispatching.me else { return }
        dispatching.other = true
        observer.on(event)
        if !disposable.my.isDisposed {
          disposable.my.dispose()
        }
      }

      return CompositeDisposable([disposable.my, disposable.other])
    }
  }

  /// Propagate events only from a signal that starts emitting first.
  public func amb<O: SignalProtocol>(with other: O) -> Signal<Element, Error> where O.Element == Element, O.Error == Error {
    return _amb(with: other)
  }

  fileprivate func _combineLatest<O: SignalProtocol, U>(with other: O, combine: @escaping (Element, O.Element) -> U) -> Signal<U, Error> where O.Error == Error {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "com.reactivekit.combinelatestwith")

      var elements: (my: Element?, other: O.Element?)
      var completions: (me: Bool, other: Bool) = (false, false)
      let compositeDisposable = CompositeDisposable()

      func onAnyNext() {
        if let myElement = elements.my, let otherElement = elements.other {
          let combination = combine(myElement, otherElement)
          observer.next(combination)
        }
      }

      func onAnyCompleted() {
        if completions.me == true && completions.other == true {
          observer.completed()
        }
      }

      compositeDisposable += self.observe { event in
        lock.lock(); defer { lock.unlock() }
        switch event {
        case .next(let element):
          elements.my = element
          onAnyNext()
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions.me = true
          onAnyCompleted()
        }
      }

      compositeDisposable += other.observe { event in
        lock.lock(); defer { lock.unlock() }
        switch event {
        case .next(let element):
          elements.other = element
          onAnyNext()
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions.other = true
          onAnyCompleted()
        }
      }

      return compositeDisposable
    }
  }

  /// Emit a combination of latest elements from each signal. Starts when both signals emit at least one element,
  /// and emits `.next` when either signal generates an element by calling `combine` on the two latest elements.
  public func combineLatest<O: SignalProtocol, U>(with other: O, combine: @escaping (Element, O.Element) -> U) -> Signal<U, Error> where O.Error == Error {
    return _combineLatest(with: other, combine: combine)
  }

  /// Emit a pair of latest elements from each signal. Starts when both signals emit at least one element,
  /// and emits `.next` when either signal generates an element.
  public func combineLatest<O: SignalProtocol>(with other: O) -> Signal<(Element, O.Element), Error> where O.Error == Error {
    return _combineLatest(with: other, combine: { ($0, $1) })
  }

  /// Merge emissions from both the receiver and the other signal into one signal.
  public func merge<O: SignalProtocol>(with other: O) -> Signal<Element, Error> where O.Element == Element, O.Error == Error {
    return Signal.sequence([self.toSignal(), other.toSignal()]).merge()
  }

  fileprivate func _zip<O: SignalProtocol, U>(with other: O, combine: @escaping (Element, O.Element) -> U) -> Signal<U, Error> where O.Error == Error {
    return Signal { observer in
      let lock = NSRecursiveLock(name: "zip")

      var buffers: (my: [Element], other: [O.Element]) = ([], [])
      var completions: (me: Bool, other: Bool) = (false, false)
      let compositeDisposable = CompositeDisposable()

      let dispatchIfPossible = {
        while !buffers.my.isEmpty && !buffers.other.isEmpty {
          let element = combine(buffers.my[0], buffers.other[0])
          observer.next(element)
          buffers.my.removeFirst()
          buffers.other.removeFirst()
        }
      }

      func completeIfPossible() {
        if (buffers.my.isEmpty && completions.me) || (buffers.other.isEmpty && completions.other) {
          observer.completed()
        }
      }

      compositeDisposable += self.observe { event in
        lock.lock(); defer { lock.unlock() }
        switch event {
        case .next(let element):
          buffers.my.append(element)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions.me = true
        }
        dispatchIfPossible()
        completeIfPossible()
      }

      compositeDisposable += other.observe { event in
        lock.lock(); defer { lock.unlock() }
        switch event {
        case .next(let element):
          buffers.other.append(element)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions.other = true
        }
        dispatchIfPossible()
        completeIfPossible()
      }

      return compositeDisposable
    }
  }

  /// Emit elements from the receiver and the other signal in pairs.
  /// This differs from `combineLatest` in that the combinations are produced from elements at same positions.
  public func zip<O: SignalProtocol, U>(with other: O, combine: @escaping (Element, O.Element) -> U) -> Signal<U, Error> where O.Error == Error {
    return _zip(with: other, combine: combine)
  }

  /// Emit elements from the receiver and the other signal in pairs.
  /// This differs from `combineLatest` in that the pairs are produced from elements at same positions.
  public func zip<O: SignalProtocol>(with other: O) -> Signal<(Element, O.Element), Error> where O.Error == Error {
    return _zip(with: other, combine: { ($0, $1) })
  }

  fileprivate func _with<O: SignalProtocol, U>(latestFrom other: O, combine: @escaping (Element, O.Element) -> U) -> Signal<U, Error> where O.Error == Error {
    return Signal { observer in

      var latest: O.Element? = nil
      let compositeDisposable = CompositeDisposable()

      compositeDisposable += other.observe { event in
        switch event {
        case .next(let element):
          latest = element
        case .failed(let error):
          observer.failed(error)
        case .completed:
          break
        }
      }

      compositeDisposable += self.observe { event in
        switch event {
        case .completed:
          observer.completed()
        case .failed(let error):
          observer.failed(error)
        case .next(let element):
          if let latest = latest {
            observer.next(combine(element, latest))
          }
        }
      }

      return compositeDisposable
    }
  }

  /// Combines the receiver and the other signal into a signal of combinations of elements whenever the
  /// receiver emits an element with the latest element from the other signal.
  public func with<O: SignalProtocol, U>(latestFrom other: O, combine: @escaping (Element, O.Element) -> U) -> Signal<U, Error> where O.Error == Error {
    return _with(latestFrom: other, combine: combine)
  }

  /// Combines the receiver and the other signal into a signal of pairs of elements whenever the
  /// receiver emits an element with the latest element from the other signal.
  public func with<O: SignalProtocol>(latestFrom other: O) -> Signal<(Element, O.Element), Error> where O.Error == Error {
    return _with(latestFrom: other, combine: { ($0, $1) })
  }
}

extension SignalProtocol where Error == NoError {

  /// Safe error casting from NoError to some Error type.
  public func castError<E>() -> Signal<Element, E> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          observer.next(element)
        case .completed:
          observer.completed()
        case .failed:
          break // will never happen because of NoError constraint
        }
      }
    }
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapLatest<O: SignalProtocol>(_ transform: @escaping (Element) -> O) -> Signal<O.Element, O.Error> {
    return castError().map(transform).switchToLatest()
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapMerge<O: SignalProtocol>(_ transform: @escaping (Element) -> O) -> Signal<O.Element, O.Error> {
    return castError().map(transform).merge()
  }

  /// Map each event into a signal and then flatten inner signals.
  public func flatMapConcat<O: SignalProtocol>(_ transform: @escaping (Element) -> O) -> Signal<O.Element, O.Error>  {
    return castError().map(transform).concat()
  }

  /// Transform each element by applying `transform` on it.
  public func tryMap<U, E>(_ transform: @escaping (Element) -> Result<U, E>) -> Signal<U, E> {
    return Signal { observer in
      return self.observe { event in
        switch event {
        case .next(let element):
          switch transform(element) {
          case .success(let value):
            observer.next(value)
          case .failure(let error):
            observer.failed(error)
          }
        case .failed:
          break  // will never happen because of NoError constraint
        case .completed:
          observer.completed()
        }
      }
    }
  }

  /// Propagate events only from a signal that starts emitting first.
  public func amb<O: SignalProtocol>(with other: O) -> Signal<Element, O.Error> where O.Element == Element {
    return castError()._amb(with: other)
  }

  /// Emit a combination of latest elements from each signal. Starts when both signals emit at least one element,
  /// and emits `.next` when either signal generates an element by calling `combine` on the two latest elements.
  public func combineLatest<O: SignalProtocol, U>(with other: O, combine: @escaping (Element, O.Element) -> U) -> Signal<U, O.Error> {
    return castError()._combineLatest(with: other, combine: combine)
  }

  /// Emit a pair of latest elements from each signal. Starts when both signals emit at least one element,
  /// and emits `.next` when either signal generates an element.
  public func combineLatest<O: SignalProtocol>(with other: O) -> Signal<(Element, O.Element), O.Error> {
    return castError()._combineLatest(with: other, combine: { ($0, $1) })
  }

  /// Merge emissions from both the receiver and the other signal into one signal.
  public func merge<O: SignalProtocol>(with other: O) -> Signal<Element, O.Error> where O.Element == Element {
    return Signal.sequence([toSignal().castError(), other.toSignal()]).merge()
  }

  /// Emit elements from the receiver and the other signal in pairs.
  /// This differs from `combineLatest` in that the combinations are produced from elements at same positions.
  public func zip<O: SignalProtocol, U>(with other: O, combine: @escaping (Element, O.Element) -> U) -> Signal<U, O.Error> {
    return castError()._zip(with: other, combine: combine)
  }

  /// Emit elements from the receiver and the other signal in pairs.
  /// This differs from `combineLatest` in that the pairs are produced from elements at same positions.
  public func zip<O: SignalProtocol>(with other: O) -> Signal<(Element, O.Element), O.Error> {
    return castError()._zip(with: other, combine: { ($0, $1) })
  }

  /// Combines the receiver and the other signal into a signal of combinations of elements whenever the
  /// receiver emits an element with the latest element from the other signal.
  public func with<O: SignalProtocol, U>(latestFrom other: O, combine: @escaping (Element, O.Element) -> U) -> Signal<U, O.Error> {
    return castError()._with(latestFrom: other, combine: combine)
  }

  /// Combines the receiver and the other signal into a signal of pairs of elements whenever the
  /// receiver emits an element with the latest element from the other signal.
  public func with<O: SignalProtocol>(latestFrom other: O) -> Signal<(Element, O.Element), O.Error> {
    return castError()._with(latestFrom: other, combine: { ($0, $1) })
  }
}

// MARK: Standalone functions

/// Combine an array of signals into one. See `combineLatest(with:)` for more info.
public func combineLatest<Element, Result, Error>(_ signals: [Signal<Element, Error>], combine: @escaping ([Element]) -> Result) -> Signal<Result, Error> {
  return Signal { observer in
    let disposable = CompositeDisposable()
    var elements = Array<Element?>(repeating: nil, count: signals.count)
    var completions = Array(repeating: false, count: signals.count)

    for (idx, signal) in signals.enumerated() {
      disposable += signal.observe { event in
        switch event {
        case .next(let element):
          elements[idx] = element
          if elements.reduce(true, { $0 && ($1 != nil) }) {
            observer.next(combine(elements.map { $0! }))
          }
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions[idx] = true
          if completions.reduce(true, { $0 && $1 }) {
            observer.completed()
          }
        }
      }
    }

    return disposable
  }
}

/// Merge an array of signals into one. See `merge(with:)` for more info.
public func merge<Element, Error>(_ signals: [Signal<Element, Error>]) -> Signal<Element, Error> {
  return Signal { observer in
    
    guard signals.count > 0 else {
      observer.completed()
      return NonDisposable.instance
    }

    let disposable = CompositeDisposable()
    var completions = Array(repeating: false, count: signals.count)

    for (idx, signal) in signals.enumerated() {
      disposable += signal.observe { event in
        switch event {
        case .next(let element):
          observer.next(element)
        case .failed(let error):
          observer.failed(error)
        case .completed:
          completions[idx] = true
          if completions.reduce(true, { $0 && $1 }) {
            observer.completed()
          }
        }
      }
    }

    return disposable
  }
}

